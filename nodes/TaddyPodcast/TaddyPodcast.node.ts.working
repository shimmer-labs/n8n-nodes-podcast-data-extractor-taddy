import { INodeType, INodeTypeDescription, IExecuteFunctions, INodeExecutionData, NodeOperationError, IDataObject } from 'n8n-workflow';

export class TaddyPodcast implements INodeType {
  description: INodeTypeDescription = {
    displayName: 'Podcast Data Extractor (Taddy API)',
    name: 'taddyPodcast',
    icon: 'file:taddypodcast.png',
    group: ['transform'],
    version: 1,
    description: 'Extract and analyze podcast data from 4M+ shows via Taddy API. Perfect for podcast discovery, content analysis, and automated podcast roundups.',
    defaults: {
      name: 'Podcast Data Extractor (Taddy API)',
    },
    inputs: ['main'],
    outputs: ['main'],
    credentials: [{ name: 'taddyPodcastApi', required: true }],
    properties: [
      {
        displayName: 'Operation',
        name: 'operation',
        type: 'options',
        noDataExpression: true,
        options: [
          {
            name: 'Check API Credits',
            value: 'checkCredits',
            description: 'Check remaining transcript credits for your account',
            action: 'Check remaining transcript credits',
          },
          {
            name: 'Get Episode Transcript',
            value: 'getTranscript',
            description: 'Extract transcript from a specific episode (uses credits)',
            action: 'Extract transcript from a specific episode',
          },
          {
            name: 'Get Known Podcasts',
            value: 'getKnown',
            description: 'Get well-known podcasts for testing',
            action: 'Get well known podcasts for testing',
          },
          {
            name: 'Get Latest Episodes',
            value: 'getLatestEpisodes',
            description: 'Get newly released episodes from multiple podcasts',
            action: 'Get newly released episodes from multiple podcasts',
          },
          {
            name: 'Get Multiple Podcasts',
            value: 'getMultiplePodcasts',
            description: 'Get information about multiple podcasts by UUID',
            action: 'Get information about multiple podcasts by UUID',
          },
          {
            name: 'Get Podcast by UUID',
            value: 'getPodcastByUuid',
            description: 'Get detailed information about a specific podcast',
            action: 'Get detailed information about a specific podcast',
          },
          {
            name: 'Get Podcast Episodes',
            value: 'getPodcastEpisodes',
            description: 'Get episodes list for a specific podcast',
            action: 'Get episodes for a specific podcast',
          },
          {
            name: 'Get Popular Podcasts',
            value: 'getPopularPodcasts',
            description: 'Get popular podcasts by genre or language',
            action: 'Get popular podcasts by genre or language',
          },
          {
            name: 'Get Top Charts',
            value: 'getTopCharts',
            description: 'Get top podcast charts by genre',
            action: 'Get top podcast charts by genre',
          },
          {
            name: 'Search Podcasts',
            value: 'searchPodcasts',
            description: 'Search for podcasts and episodes with advanced filters',
            action: 'Search for podcasts and episodes with advanced filters',
          },
        ],
        default: 'searchPodcasts',
        description: 'Choose the operation to perform',
      },
      // Search Podcasts fields
      {
        displayName: 'Search Query',
        name: 'searchQuery',
        type: 'string',
        default: '',
        placeholder: 'e.g., technology, joe rogan, true crime',
        description: 'Enter search terms to find podcasts or episodes. Can be podcast names, topics, or keywords.',
        displayOptions: {
          show: {
            operation: ['searchPodcasts'],
          },
        },
      },
      {
        displayName: 'Max Results',
        name: 'maxResults',
        type: 'number',
        default: 10,
        description: 'Maximum number of results to return (1-25)',
        hint: 'Results are limited client-side after API response',
        typeOptions: {
          minValue: 1,
          maxValue: 25,
        },
        displayOptions: {
          show: {
            operation: ['searchPodcasts', 'getPodcastEpisodes', 'getPopularPodcasts', 'getTopCharts'],
          },
        },
      },
      // Get Multiple Podcasts fields
      {
        displayName: 'Podcast UUIDs',
        name: 'podcastUuids',
        type: 'string',
        default: '',
        placeholder: 'uuid1,uuid2,uuid3',
        description: 'Comma-separated list of podcast UUIDs (max 25)',
        hint: 'Get UUIDs from search results or previous operations',
        displayOptions: {
          show: {
            operation: ['getMultiplePodcasts'],
          },
        },
      },
      // Get Latest Episodes fields
      {
        displayName: 'Input Type',
        name: 'latestEpisodesInputType',
        type: 'options',
        options: [
          { name: 'Podcast UUIDs', value: 'uuids' },
          { name: 'RSS URLs', value: 'rssUrls' },
        ],
        default: 'uuids',
        description: 'Choose how to specify the podcasts',
        displayOptions: {
          show: {
            operation: ['getLatestEpisodes'],
          },
        },
      },
      {
        displayName: 'Podcast UUIDs',
        name: 'latestEpisodesUuids',
        type: 'string',
        default: '',
        placeholder: 'uuid1,uuid2,uuid3',
        description: 'Comma-separated list of podcast UUIDs (max 1000)',
        hint: 'Perfect for tracking multiple podcasts for weekly roundups',
        displayOptions: {
          show: {
            operation: ['getLatestEpisodes'],
            latestEpisodesInputType: ['uuids'],
          },
        },
      },
      {
        displayName: 'RSS URLs',
        name: 'latestEpisodesRssUrls',
        type: 'string',
        default: '',
        placeholder: 'https://example.com/feed1.xml,https://example.com/feed2.xml',
        description: 'Comma-separated list of RSS feed URLs (max 1000)',
        displayOptions: {
          show: {
            operation: ['getLatestEpisodes'],
            latestEpisodesInputType: ['rssUrls'],
          },
        },
      },
      // Popular & Top Charts fields
      {
        displayName: 'Filter by Genres',
        name: 'popularGenres',
        type: 'multiOptions',
        options: [
          { name: 'Arts', value: 'PODCASTSERIES_ARTS' },
          { name: 'Business', value: 'PODCASTSERIES_BUSINESS' },
          { name: 'Comedy', value: 'PODCASTSERIES_COMEDY' },
          { name: 'Education', value: 'PODCASTSERIES_EDUCATION' },
          { name: 'Fiction', value: 'PODCASTSERIES_FICTION' },
          { name: 'Government', value: 'PODCASTSERIES_GOVERNMENT' },
          { name: 'Health & Fitness', value: 'PODCASTSERIES_HEALTH_AND_FITNESS' },
          { name: 'History', value: 'PODCASTSERIES_HISTORY' },
          { name: 'Kids & Family', value: 'PODCASTSERIES_KIDS_AND_FAMILY' },
          { name: 'Music', value: 'PODCASTSERIES_MUSIC' },
          { name: 'News', value: 'PODCASTSERIES_NEWS' },
          { name: 'Religion & Spirituality', value: 'PODCASTSERIES_RELIGION_AND_SPIRITUALITY' },
          { name: 'Science', value: 'PODCASTSERIES_SCIENCE' },
          { name: 'Society & Culture', value: 'PODCASTSERIES_SOCIETY_AND_CULTURE' },
          { name: 'Sports', value: 'PODCASTSERIES_SPORTS' },
          { name: 'Technology', value: 'PODCASTSERIES_TECHNOLOGY' },
          { name: 'True Crime', value: 'PODCASTSERIES_TRUE_CRIME' },
          { name: 'TV & Film', value: 'PODCASTSERIES_TV_AND_FILM' },
        ],
        default: [],
        description: 'Filter popular podcasts by specific genres',
        displayOptions: {
          show: {
            operation: ['getPopularPodcasts', 'getTopCharts'],
          },
        },
      },
      {
        displayName: 'Filter by Language',
        name: 'popularLanguage',
        type: 'options',
        options: [
          { name: 'All Languages', value: '' },
          { name: 'Arabic', value: 'ARABIC' },
          { name: 'Chinese', value: 'CHINESE' },
          { name: 'Dutch', value: 'DUTCH_FLEMISH' },
          { name: 'English', value: 'ENGLISH' },
          { name: 'French', value: 'FRENCH' },
          { name: 'German', value: 'GERMAN' },
          { name: 'Hindi', value: 'HINDI' },
          { name: 'Italian', value: 'ITALIAN' },
          { name: 'Japanese', value: 'JAPANESE' },
          { name: 'Korean', value: 'KOREAN' },
          { name: 'Portuguese', value: 'PORTUGUESE' },
          { name: 'Russian', value: 'RUSSIAN' },
          { name: 'Spanish', value: 'SPANISH' },
          { name: 'Swedish', value: 'SWEDISH' },
        ],
        default: '',
        description: 'Filter popular podcasts by language',
        displayOptions: {
          show: {
            operation: ['getPopularPodcasts'],
          },
        },
      },
      // Advanced Search Options
      {
        displayName: 'Advanced Options',
        name: 'advancedOptions',
        type: 'collection',
        placeholder: 'Add Option',
        default: {},
        displayOptions: {
          show: {
            operation: ['searchPodcasts'],
          },
        },
        options: [
          {
            displayName: 'Content Types',
            name: 'filterForTypes',
            type: 'multiOptions',
            options: [
              { name: 'Podcast Episodes', value: 'PODCASTEPISODE' },
              { name: 'Podcast Series', value: 'PODCASTSERIES' },
            ],
            default: ['PODCASTSERIES'],
            description: 'Types of content to search for',
          },
          {
            displayName: 'Genres',
            name: 'filterForGenres',
            type: 'multiOptions',
            options: [
              { name: 'Arts', value: 'PODCASTSERIES_ARTS' },
              { name: 'Business', value: 'PODCASTSERIES_BUSINESS' },
              { name: 'Comedy', value: 'PODCASTSERIES_COMEDY' },
              { name: 'Education', value: 'PODCASTSERIES_EDUCATION' },
              { name: 'Fiction', value: 'PODCASTSERIES_FICTION' },
              { name: 'Health & Fitness', value: 'PODCASTSERIES_HEALTH_AND_FITNESS' },
              { name: 'News', value: 'PODCASTSERIES_NEWS' },
              { name: 'Science', value: 'PODCASTSERIES_SCIENCE' },
              { name: 'Sports', value: 'PODCASTSERIES_SPORTS' },
              { name: 'Technology', value: 'PODCASTSERIES_TECHNOLOGY' },
              { name: 'True Crime', value: 'PODCASTSERIES_TRUE_CRIME' },
            ],
            default: [],
            description: 'Filter by podcast genres',
          },
          {
            displayName: 'Languages',
            name: 'filterForLanguages',
            type: 'multiOptions',
            options: [
              { name: 'Chinese', value: 'CHINESE' },
              { name: 'English', value: 'ENGLISH' },
              { name: 'French', value: 'FRENCH' },
              { name: 'German', value: 'GERMAN' },
              { name: 'Japanese', value: 'JAPANESE' },
              { name: 'Portuguese', value: 'PORTUGUESE' },
              { name: 'Russian', value: 'RUSSIAN' },
              { name: 'Spanish', value: 'SPANISH' },
            ],
            default: [],
            description: 'Filter by podcast languages',
          },
          {
            displayName: 'Match Strategy',
            name: 'matchBy',
            type: 'options',
            options: [
              { name: 'All Terms', value: 'ALL_TERMS' },
              { name: 'Exact Phrase', value: 'EXACT_PHRASE' },
              { name: 'Most Terms', value: 'MOST_TERMS' },
            ],
            default: 'MOST_TERMS',
            description: 'How strictly to match search terms',
          },
          {
            displayName: 'Has Transcript',
            name: 'filterForHasTranscript',
            type: 'boolean',
            default: false,
            description: 'Only return episodes with transcripts available',
            hint: 'Useful for AI-powered summaries',
          },
          {
            displayName: 'Published After',
            name: 'filterForPublishedAfter',
            type: 'dateTime',
            default: '',
            description: 'Only return content published after this date',
            hint: 'Format: YYYY-MM-DD or YYYY-MM-DD HH:MM:SS',
          },
          {
            displayName: 'Sort By',
            name: 'sortBy',
            type: 'options',
            options: [
              { name: 'Relevance', value: 'EXACTNESS' },
              { name: 'Popularity', value: 'POPULARITY' },
            ],
            default: 'EXACTNESS',
            description: 'How to sort search results',
          },
        ],
      },
      // Single Podcast fields
      {
        displayName: 'Podcast UUID',
        name: 'podcastUuid',
        type: 'string',
        default: '',
        placeholder: 'e.g., cb8d858a-3ef4-4645-8942-67e55c0927f2',
        description: 'The unique identifier of the podcast',
        hint: 'Get this from search results or other operations',
        displayOptions: {
          show: {
            operation: ['getPodcastEpisodes', 'getPodcastByUuid'],
          },
        },
      },
      // Episode fields
      {
        displayName: 'Episode UUID',
        name: 'episodeUuid',
        type: 'string',
        default: '',
        placeholder: 'e.g., 123e4567-e89b-12d3-a456-426614174000',
        description: 'The unique identifier of the episode',
        hint: 'Get this from episode results. Transcript extraction uses API credits.',
        displayOptions: {
          show: {
            operation: ['getTranscript'],
          },
        },
      },
    ],
  };

  async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
    const items = this.getInputData();
    const returnData: INodeExecutionData[] = [];

    // Helper function for making API requests with retry logic
    const makeApiRequest = async (query: string, variables?: IDataObject, useGraphqlPath: boolean = false) => {
      const credentials = await this.getCredentials('taddyPodcastApi');
      const userId = credentials.userId as string;
      const apiKey = credentials.apiKey as string;
      const url = useGraphqlPath ? 'https://api.taddy.org/graphql' : 'https://api.taddy.org';
      
      return await this.helpers.httpRequest({
        method: 'POST',
        url,
        headers: {
          'X-USER-ID': userId,
          'X-API-KEY': apiKey,
          'Content-Type': 'application/json',
        },
        body: variables ? { query, variables } : { query },
      });
    };

    const requestWithRetry = async (query: string, variables?: IDataObject) => {
      try {
        return await makeApiRequest(query, variables, false);
      } catch (err: unknown) {
        const error = err as { response?: { status?: number }; message?: string };
        const needsGraphqlPath = 
          error?.response?.status === 400 ||
          /Cannot query field|Unknown argument|Bad Request/i.test(String(error));

        if (needsGraphqlPath) {
          return await makeApiRequest(query, variables, true);
        }
        throw err;
      }
    };

    for (let i = 0; i < items.length; i++) {
      const operation = this.getNodeParameter('operation', i) as string;
      let responseData: IDataObject = {};

      try {
        if (operation === 'checkCredits') {
          const query = `{ getTranscriptCreditsRemaining }`;
          const apiResponse = await requestWithRetry(query);

          responseData = {
            operation: 'checkCredits',
            credits: apiResponse.data?.getTranscriptCreditsRemaining || 0,
            message: `You have ${apiResponse.data?.getTranscriptCreditsRemaining || 0} transcript credits remaining`,
          };

        } else if (operation === 'getKnown') {
          const knownPodcasts = ['The Daily', 'This American Life', 'Joe Rogan Experience', 'Serial', 'Radiolab'];
          const results = [];

          const query = `
            query getPodcastSeries($name: String!) {
              getPodcastSeries(name: $name) {
                uuid
                name
                itunesId
                description
                imageUrl
                totalEpisodesCount
                language
                genres
              }
            }
          `;

          for (const name of knownPodcasts) {
            try {
              const apiResponse = await requestWithRetry(query, { name });
              if (apiResponse.data?.getPodcastSeries) {
                results.push(apiResponse.data.getPodcastSeries);
              }
            } catch {
              // Skip failed podcasts
            }
          }

          responseData = {
            operation: 'getKnownPodcasts',
            podcasts: results,
            totalFound: results.length,
          };

        } else if (operation === 'getLatestEpisodes') {
          const inputType = this.getNodeParameter('latestEpisodesInputType', i) as string;
          let uuids: string[] = [];
          let rssUrls: string[] = [];

          if (inputType === 'uuids') {
            const uuidsInput = this.getNodeParameter('latestEpisodesUuids', i) as string;
            uuids = uuidsInput.split(',').map(u => u.trim()).filter(u => u);
          } else {
            const rssUrlsInput = this.getNodeParameter('latestEpisodesRssUrls', i) as string;
            rssUrls = rssUrlsInput.split(',').map(u => u.trim()).filter(u => u);
          }

          const query = `
            query GetLatestEpisodes($uuids: [ID], $rssUrls: [String]) {
              getLatestPodcastEpisodes(uuids: $uuids, rssUrls: $rssUrls) {
                uuid
                name
                description
                datePublished
                audioUrl
                duration
                podcastSeries {
                  uuid
                  name
                  imageUrl
                }
              }
            }
          `;

          const variables: IDataObject = {};
          if (uuids.length > 0) variables.uuids = uuids;
          if (rssUrls.length > 0) variables.rssUrls = rssUrls;

          const apiResponse = await requestWithRetry(query, variables);

          responseData = {
            operation: 'getLatestEpisodes',
            episodes: apiResponse.data?.getLatestPodcastEpisodes || [],
            totalEpisodes: apiResponse.data?.getLatestPodcastEpisodes?.length || 0,
            inputType,
            inputCount: uuids.length || rssUrls.length,
          };

        } else if (operation === 'getMultiplePodcasts') {
          const uuidsInput = this.getNodeParameter('podcastUuids', i) as string;
          const uuids = uuidsInput.split(',').map(u => u.trim()).filter(u => u).slice(0, 25);

          const query = `
            query GetMultiplePodcasts($uuids: [ID]) {
              getMultiplePodcastSeries(uuids: $uuids) {
                uuid
                name
                description
                imageUrl
                totalEpisodesCount
                language
                genres
                itunesId
                websiteUrl
              }
            }
          `;

          const apiResponse = await requestWithRetry(query, { uuids });

          responseData = {
            operation: 'getMultiplePodcasts',
            podcasts: apiResponse.data?.getMultiplePodcastSeries || [],
            totalReturned: apiResponse.data?.getMultiplePodcastSeries?.length || 0,
            requestedCount: uuids.length,
          };

        } else if (operation === 'getPopularPodcasts') {
          const maxResults = this.getNodeParameter('maxResults', i) as number;
          const genres = this.getNodeParameter('popularGenres', i) as string[];
          const language = this.getNodeParameter('popularLanguage', i) as string;

          const query = `
            query GetPopularContent($filterByGenres: [Genre!], $filterByLanguage: Language, $limitPerPage: Int) {
              getPopularContent(
                filterByGenres: $filterByGenres
                filterByLanguage: $filterByLanguage
                limitPerPage: $limitPerPage
                taddyType: PODCASTSERIES
              ) {
                podcastSeries {
                  uuid
                  name
                  description
                  imageUrl
                  totalEpisodesCount
                  language
                  genres
                  popularityRank
                }
              }
            }
          `;

          const variables: IDataObject = {
            limitPerPage: Math.min(maxResults, 25),
          };
          if (genres.length > 0) variables.filterByGenres = genres;
          if (language) variables.filterByLanguage = language;

          const apiResponse = await requestWithRetry(query, variables);

          responseData = {
            operation: 'getPopularPodcasts',
            podcasts: apiResponse.data?.getPopularContent?.podcastSeries || [],
            totalReturned: apiResponse.data?.getPopularContent?.podcastSeries?.length || 0,
            filters: {
              genres: genres.length > 0 ? genres : 'all',
              language: language || 'all',
            },
          };

        } else if (operation === 'getTopCharts') {
          const maxResults = this.getNodeParameter('maxResults', i) as number;
          const genres = this.getNodeParameter('popularGenres', i) as string[];

          const query = `
            query GetTopCharts($genres: [Genre!], $limitPerPage: Int) {
              getTopChartsByGenres(
                genres: $genres
                limitPerPage: $limitPerPage
                taddyType: PODCASTSERIES
              ) {
                podcastSeries {
                  uuid
                  name
                  description
                  imageUrl
                  totalEpisodesCount
                  language
                  genres
                  itunesId
                }
              }
            }
          `;

          const variables: IDataObject = {
            limitPerPage: Math.min(maxResults, 25),
            genres: genres.length > 0 ? genres : ['PODCASTSERIES_TECHNOLOGY'],
          };

          const apiResponse = await requestWithRetry(query, variables);

          responseData = {
            operation: 'getTopCharts',
            podcasts: apiResponse.data?.getTopChartsByGenres?.podcastSeries || [],
            totalReturned: apiResponse.data?.getTopChartsByGenres?.podcastSeries?.length || 0,
            genres: genres.length > 0 ? genres : ['default'],
          };

        } else if (operation === 'searchPodcasts') {
          const searchQuery = this.getNodeParameter('searchQuery', i) as string;
          const maxResults = this.getNodeParameter('maxResults', i) as number;
          const advancedOptions = this.getNodeParameter('advancedOptions', i) as IDataObject;

          const variables: IDataObject = { term: searchQuery };

          if (advancedOptions.filterForTypes) {
            variables.filterForTypes = advancedOptions.filterForTypes;
          }
          if (advancedOptions.filterForGenres) {
            variables.filterForGenres = advancedOptions.filterForGenres;
          }
          if (advancedOptions.filterForLanguages) {
            variables.filterForLanguages = advancedOptions.filterForLanguages;
          }
          if (advancedOptions.matchBy) {
            variables.matchBy = advancedOptions.matchBy;
          }
          if (advancedOptions.sortBy) {
            variables.sortBy = advancedOptions.sortBy;
          }
          if (advancedOptions.filterForHasTranscript !== undefined) {
            variables.filterForHasTranscript = advancedOptions.filterForHasTranscript;
          }
          if (advancedOptions.filterForPublishedAfter) {
            const dateString = advancedOptions.filterForPublishedAfter as string;
            variables.filterForPublishedAfter = Math.floor(new Date(dateString).getTime() / 1000);
          }

          const query = `
            query Search(
              $term: String
              $filterForTypes: [SearchContentType]
              $filterForGenres: [Genre]
              $filterForLanguages: [Language]
              $matchBy: SearchMatchType
              $sortBy: SearchSortOrder
              $filterForHasTranscript: Boolean
              $filterForPublishedAfter: Int
            ) {
              search(
                term: $term
                filterForTypes: $filterForTypes
                filterForGenres: $filterForGenres
                filterForLanguages: $filterForLanguages
                matchBy: $matchBy
                sortBy: $sortBy
                filterForHasTranscript: $filterForHasTranscript
                filterForPublishedAfter: $filterForPublishedAfter
              ) {
                searchId
                podcastSeries {
                  uuid
                  name
                  description
                  imageUrl
                  rssUrl
                  itunesId
                  language
                  totalEpisodesCount
                  popularityRank
                  itunesInfo { 
                    uuid 
                    baseArtworkUrlOf(size: 640) 
                  }
                  genres
                }
                podcastEpisodes {
                  uuid
                  name
                  subtitle
                  description
                  audioUrl
                  imageUrl
                  datePublished
                  duration
                  podcastSeries {
                    uuid
                    name
                    imageUrl
                  }
                }
              }
            }
          `;

          const apiResponse = await requestWithRetry(query, variables);
          const searchData = apiResponse.data?.search || {};
          
          let podcastResults = searchData.podcastSeries || [];
          let episodeResults = searchData.podcastEpisodes || [];
          
          // Apply client-side limit
          if (podcastResults.length > maxResults) {
            podcastResults = podcastResults.slice(0, maxResults);
          }
          if (episodeResults.length > maxResults) {
            episodeResults = episodeResults.slice(0, maxResults);
          }

          responseData = {
            operation,
            searchQuery,
            maxResults,
            advancedOptions,
            searchId: searchData.searchId || '',
            podcastSeries: podcastResults,
            podcastEpisodes: episodeResults,
            totalPodcastsFound: searchData.podcastSeries?.length || 0,
            totalEpisodesFound: searchData.podcastEpisodes?.length || 0,
            podcastsReturned: podcastResults.length,
            episodesReturned: episodeResults.length,
          };

        } else if (operation === 'getPodcastByUuid') {
          const podcastUuid = this.getNodeParameter('podcastUuid', i) as string;
          
          if (!podcastUuid) {
            throw new NodeOperationError(this.getNode(), 'Podcast UUID is required');
          }

          const query = `
            query getPodcastSeries($uuid: ID!) {
              getPodcastSeries(uuid: $uuid) {
                uuid
                name
                itunesId
                description
                imageUrl
                rssUrl
                language
                totalEpisodesCount
                authorName
                websiteUrl
                itunesInfo { 
                  uuid 
                  baseArtworkUrlOf(size: 640)
                  summary
                }
                genres
              }
            }
          `;

          const apiResponse = await requestWithRetry(query, { uuid: podcastUuid });

          responseData = {
            operation,
            podcastUuid,
            result: apiResponse.data?.getPodcastSeries || null,
          };

        } else if (operation === 'getPodcastEpisodes') {
          const podcastUuid = this.getNodeParameter('podcastUuid', i) as string;
          const maxResults = this.getNodeParameter('maxResults', i) as number;
          
          if (!podcastUuid) {
            throw new NodeOperationError(this.getNode(), 'Podcast UUID is required');
          }

          const query = `
            query GetPodcastEpisodes($uuid: ID!) {
              getPodcastSeries(uuid: $uuid) {
                uuid
                name
                episodes(limitPerPage: 25, sortOrder: LATEST) {
                  uuid
                  name
                  description
                  audioUrl
                  duration
                  episodeNumber
                  seasonNumber
                  datePublished
                  transcriptUrls
                  imageUrl
                  fileType
                }
              }
            }
          `;

          const apiResponse = await requestWithRetry(query, { uuid: podcastUuid });
          const podcast = apiResponse.data?.getPodcastSeries;
          let episodes = podcast?.episodes || [];

          if (episodes.length > maxResults) {
            episodes = episodes.slice(0, maxResults);
          }

          responseData = {
            operation,
            podcastUuid,
            podcastName: podcast?.name || 'Unknown',
            episodes,
            totalEpisodes: podcast?.episodes?.length || 0,
            returned: episodes.length,
          };

        } else if (operation === 'getTranscript') {
          const episodeUuid = this.getNodeParameter('episodeUuid', i) as string;
          
          if (!episodeUuid) {
            throw new NodeOperationError(this.getNode(), 'Episode UUID is required');
          }

          const query = `
            query GetEpisodeTranscript($uuid: ID!) {
              getPodcastEpisode(uuid: $uuid) {
                uuid
                name
                description
                transcript
                transcriptUrlsWithDetails {
                  url
                  type
                  language
                  hasTimecodes
                  isTaddyExclusive
                }
              }
            }
          `;

          const apiResponse = await requestWithRetry(query, { uuid: episodeUuid });
          const episode = apiResponse.data?.getPodcastEpisode;

          responseData = {
            operation,
            episodeUuid,
            episodeName: episode?.name || 'Unknown',
            transcript: episode?.transcript || [],
            transcriptSegments: episode?.transcript?.length || 0,
            transcriptText: (episode?.transcript || []).join('\n'),
            transcriptUrls: episode?.transcriptUrlsWithDetails || [],
          };
        }

        returnData.push({ json: responseData });

      } catch (error: unknown) {
        const apiError = error as { response?: { status?: number; statusText?: string; data?: unknown }; message?: string };
        const errorData: IDataObject = {
          operation,
          error: apiError.message || 'Unknown error',
          status: apiError.response?.status || 0,
          statusText: apiError.response?.statusText || '',
          responseBody: JSON.stringify(apiError.response?.data || {}),
        };

        if (this.continueOnFail()) {
          returnData.push({ json: errorData });
        } else {
          throw new NodeOperationError(this.getNode(), `Taddy API Error: ${JSON.stringify(errorData, null, 2)}`);
        }
      }
    }

    return [returnData];
  }
}
